raspberry piとARMプロセッサについてはトップレベルのREADMEを参照。プログラムのロードと実行方法も同じく。

この例は古いpi1ボード用。他のraspberry piについては他のディレクトリ参照。

pi1はGPIO１６にLEDを持つ。

説明に少しの時間を要する最初の例である。他にもベアメタルとGNUツールについてとりとめのない説明があるのでそれとかぶらないように気をつける。

raspberry piの最もよくある使い方としてなんかのLinuxを動かすことがあるだろう。３つの主なファイル、bootloader.bin, start.elf, kernel.imgがある。最初の２つはGPUで動くプログラムで、最後のがARM用だ。他にファイルがなければ(config.txtは用意しない)、そいつら(start.elf GPUコード)がkernel.imgをRAMの0x8000にコピーし、LinuxブートのためにARMを準備させるような、なんかのコードを0x000に配置する。それから、0x8000を呼ぶ。我々は単純にkernel.imgをプログラムと置き換える。config.txtとは関わらない。使わなきゃいけないわけでもないし、大体のpiボードは使ってないし、使わないほうがよくテストできる。時間が経つと、config.txtの項目は増えたり減ったり名前が変わったり、いくつかはドキュメントされてないし、諸々。そういうわけで、これに頼りたくない。単純にkernel.imgを置き換え、他は置いておこう。

vectors.sはこのプログラムのエントリポイントで、LinuxのようなOS上のアプリケーションでさえmain関数を呼び出す前のスタートアップアセンブリがある。このプロセッサについては、最小構成としてはstackポインタをセットし、main関数を呼ぶことである。main関数を見ると余計なものをくっつけるコンパイラがいるので、main()以外の名前の、組込みシステムでよく使われるような名前を使っている。
習慣より、notmain()を使うことにした。これは *ベアメタル* であって、よくあるプログラムではない。

+++.data+++とか.bssについて書いているとこを見て欲しい。それらを使ってないので、bootstrap(最初のC関数を呼ぶ前の小さなアセンブリ)はこれらセグメントを準備しなくても良い。スタックを準備してC関数を呼ぶだけである。

原著者は普段stackポインタをRAMのトップにセットする...のは嘘で、ある人は普段そういうことをするだろうが、しかしこのような数多のボードをまたがるようなコードではそれは難しい。代わりに、簡単な例としてコードと衝突しない場所にスタックを置いた。また、これはボードで変える必要はない。なぜなら、0x8000をエントリポイントとして使っているので、0x8000をスタックにセットすることで0x0000に向かって伸びていくからだ。またそれはこの例については十分な量でもある。ARMの動作は、引き算した後に書き込むので、スタック上の最初のものは0x7FFCにある。0x8000を避けて0x7FFCに置く必要はない。

GPIOピンはLEDを駆動するため出力として設定される。点滅の測度はだいたい毎秒3回くらいだが、コンパイラとか設定に依る。このプログラムは他の周辺機器(タイマーとか)に頼らず、単に時間をループで食潰し、LEDを変化させる。もしこのコード(↓)を使うのであれば、

[source, c]
----
for(ra=0;ra<0x1000;ra++) continue;
----

最適化はこう置き換えるだろう

[source, c]
----
ra = 0x1000;
----

そして、その値がもう使われることはないので、最適化はそのコードを除去するかも知れない。

これをループさせるための一つの方法としては、volatile変数を使う。これはコンパイラに、変数を使うときはいつでもRAMのから読み込み、そして書き込むと伝える。原著者は別の方法をとっている。簡単なdummy関数をアセンブリで用意する。それは単にリターンするだけ。

[source,asm]
----
.globl dummy
dummy:
    bx lr
----

同じファイル内にいないアセンブリは最適化の外側にいる。(llvmは少し違って、それはこういった他のものも見て、最適化する。gnuはしない)

それで、この外側の関数を用意して変数をループ中で渡すことで、

[source, c]
----
for(ra=0;ra<0x1000;ra++) dummy(ra);
----

コンパイラに本当にこのコードを実装しループが走るよう強制することができる。volatileにする必要がない。もしアセンブリ言語が嫌ならdummy関数を別ファイルに

[source, c]
----
void dummy ( void )
{
}
----

これは同じコードを生成する。

[source, c]
----
00000000 <dummy>:
   0:   e12fff1e    bx  lr
----

ツールチェインが最適化時にファイルをまたがるのならまだ気をつけないといけない。最適化をごまかすためにアセンブリの方法が気に入ってる。

このプログラムはLEDを駆動するためにGPIOをセットしている。時間を潰すのにループをつかい、LEDを変更し、繰り返す。点滅速度は同じプログラムなら同じになるだろう。でもコンパイラの違いやオプションは点滅速度を変えてしまうかも知れない。それは予測できないので、後の例ではタイマーを使う。同じツールでループカウントを変えれば点滅速度が変わったのがわかるだろう。

Broadcomが0x7Exxxxxxをペリフェラルのアドレスに使っているのには気をつけよう。これはGPU絡みたアドレス空間である。今のとこARMの見方では0x20xxxxxxか0x3Fxxxxxxがチップごとに使われている。pi1なら0x20xxxxxx。それで、0x7Exxxxxxを見た時は0x7Eを0x20で置き換えよう。

普通リポジトリに生成物を残さないのだが、なぜ動かないのか比較したい時もあるだろう。それで、この例では残すことにした。
