
raspberry piのARMプロセッサのprogrammers reference manualと回路図についてはトップレベルのREADMEを参照。プログラムのロードと実行方法も同じく。

このディレクトリ内のコードは今もraspberry pi1として手に入れられる古いraspberry pi用である。pi2ディレクトリraspberry pi2用。plusディレクトリはraspberry pi B+とA+用。それぞれ必要に応じて使うこと。

このシンプルな例は小さなスタックを確保する。そんなに多くは要らないのでstack用のメモリもそんなに要らない。それからGPIO16を出力に設定する。それからGPIOをセット、ウェイト、リセット、ウェイト、の繰り返しループに入る。GPIO16は、回路図によるとOK LEDに接続されている。ホストUSBポートとオーディオ出力の近くの角にあるLED達の一つね。点滅の感覚は、原著者によると毎秒数回程度。

原著者は普段stackポインタをRAMのいくつかのバンクのトップにセットする。もしバンクがひとつだけならそれのトップ。トップレベルREADMEを見て欲しいのだが、それによると0以外のどこかから始めることになっている。それで、こういうシンプルなプログラムには0x8000からプログラムを始め、0x7FFCからスタックを始めることにしている。ARMのstackポインタ(r13)はstackのトップの後のアドレスを指すので、r13を0x8000にセットするとstackは0x7FFCから始まることになり、スタックに積むとメインプログラムから離れ下に降りていく。


vectors.sはこのプログラムのエントリポイントで、LinuxのようなOS上のアプリケーションでさえmain関数を呼び出す前のスタートアップアセンブリがある。このプロセッサについては、最小構成としてはstackポインタをセットし、main関数を呼ぶことである。main関数を見ると余計なものをくっつけるコンパイラがいるので、main()以外の名前の、組込みシステムでよく使われるような名前を使っている。初期化済みの変数がなければ、.dataや.bss初期化を行う必要はない。普通、mainを呼ぶアセンブリは.dataセグメントや.bssセグメントを必要に応じて初期化する。また、リンカスクリプトは普通、アドレスやサイズについてグローバル変数を初期化するためにもっと複雑である。そういうことはしてないのでスタートアップコードはstackポインタのセットとmain関数呼び出しのみである。

例はgccやclangを使ってビルドできるようなMakefileを含んでいる。

dummy関数はコンパイラの最適化のせいで付け加えた。
例えば、

for(ra=0;ra<0x1000;ra++) continue;

これは以下に置き換えられる

ra = 0x1000;

これは欲しい挙動ではない。書いたとおりに動いて欲しいし、それでLEDは我々の遅い目でも見えるのだ。

コンパイラはdummyがCコンパイラの及ばないアセンブリであるため何をするのか知らない。それで、

for(ra=0;ra<0x1000;ra++) dummy(ra);

によってCコンパイラがdummy(0), dummy(1), dummy(2)と呼んでくれるよう正しく実装することができる。ループを多くすることもできる。これでいい。

他の方法としては、raをvolatileにすることでループを最適化されないようにする。そして、ループ中でraは読み書きされる。適宜好きな方を選べばいいだろう。

レジスタについて、このプログラムはBroadcom ARM Documentを情報として選んだ。Broadcomのドキュメントではアドレスが0x20xxxxxxではなく0x7Exxxxxxとして表示されているのに気をつけよう。
