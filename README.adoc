:linkcss:
:stylesdir: css

[quote]
このリポジトリは初代ラズパイ向けに雑多に始めた。書き直したいが遅々として進まない。異種カードを対象とした具体的な例を示すため、最近pi1, piaplusディレクトリを作り始めた。これもゆっくりではあるが。同じくREADMEも多分、書き直すだろうけど今は....




このリポジトリは低レベルの例を提供する。OS無しとか、組み込みとか低レベル組み込みとかディープ組み込み footnote:[訳注: 組み込みの中でもファームの書き換えなどがしにくい(出来ない)かなりシステム深部にあるもののことか? http://www.answers.com/article/1203162/what-is-a-deeply-embedded-system]とかベアメタルとか、言い方はともかくこういったものについて。

原著者は決してraspberry pi財団やbroadcomとは関係ない。単につくったのを、経験を共有しようと思っただけだ。 raspberry piは教育用でもあるとのことで、ベアメタル教育はPythonプログラミングとちょうど同じく重要だろうと思う。

それで、ARM11ベースのraspberry pi、言い方がよくわからないんだがたぶんraspberry pi 1と呼ばれているもの、をゲットした1年前に始めた。でも今や沢山のバリエーションがある。

ARM11 ベース (BCM2835)::
Raspberry Pi B +
Raspberry Pi B2 +
Raspberry Pi A+ +
Raspberry Pi B+ +
Raspberry Pi Zero +
Cortex-A7 ベース (BCM2836)::
Raspberry Pi 2 B
Cortex-A53 ベース (BCM2837)::
Raspberry Pi 3 B

コンピュートモジュール footnote:[http://jp.rs-online.com/web/p/processor-microcontroller-development-kits/8168003/]もあるようだが、持ってない。

例としてこれらの一般的な差異を挙げる。RAMの量はボードで違う。ペリフェラルのベースアドレスはBCM2835とBCM2836で異なる。BCM2835はkernel.imgを見にいくが、BCM2836はkernel7.imgを見にいく。ARM11ベースのZeroはBのモノが取り除かれ新しいレイアウトになったが、750Mzhから1000MHzへとオーバー(アップ?)クロックされ、GPIO 16がledである。A+とB+はledをGPIO 35と47に移動した。raspberry pi 2はB+ライクであるが、チップが異なり、多分BCM2836はBCM2835からARM11コアが除かれCortex A7が配置されたようである。raspberry pi 3はCortex A8ベースで64bit。そして、LED(LED達)をi2c GPIOエキスパンダに移動した。

これを書いている時点でplusとpi 2バージョンの例をなるべくオリジナルに基づくように、追加した。保証はしないが、blinker01の例達の差異を見ることで自分のものにできるはずだ。あるケースでは、一つのコードベースを上記3つの全てにむけて、ifdefとかそういうのを使ってビルドするのは意図的に避けている。コードを愚直に保ち、また必要に応じて複雑化する。テキストはkernel.imgと言うかも知れないが、代わりにkernel7.imgが必要かもしれない。

移植すべきraspberry pi 2の例が沢山あるのだが、今やraspberry pi 3に移植すべき例が山ほどある。これを書いている時点では、raspberry pi 3はconfig.txtなしでは32bit互換モードになる。64bit ARMの例についてはaarch64ディレクトリを参照。

我々が知っていることには、一つのオンチップGPUが

.  オンチップROMを起動
.  SDカードを読み、第一パーティションのルートにある追加のGPU固有ブートファイルbootcode.binとstart.elfを探す。(fat32フォーマットされ、loader.binはもう使われない)
.  同ディレクトリでconfig.txtを探す。これはARMのスピードやkernel.imgを読み込む場所をとかを設定できる。
.  kernel.img、ARMのブートバイナリ、を読み、メモリにコピーする。
.  リセットし、kernel.imgが書かれた場所から実行。

メモリはGPUとARMの都の間で分割されており、デフォルトでは半分こされるはず。config.txtを使ってARMにもっと割り当てる方法がある。ここではそれを心配する必要はない。

ARMによれば、kernel.imgは、デフォルトでは、0x8000に読み込まれる。

ハードウェアとプログラミングインフォメーション:

ここ
http://elinux.org/RPi_Hardware に行くとデータシートと回路図を得られる。正誤表とかもある。BCM2836については完全なデータシートは無い。だいたいBCM2835と同じなので。
ここ
http://raspberrypi.org に行くとフォーラムのタブがあり、下を見るとベアメタルのフォーラムがある。最初にして唯一の厄介なトピックはベアメタルリソースだ。そこにはいい情報がのリンクが沢山ある。
ここ
http://infocenter.arm.com にも行くとARM1176JZF-S(BCM2835)とかCortex-A7 (BCM2836)のArchitectural Reference ManualとTechnical Reference Manualが得られる。

BCM2835のドキュメントの最初でメモリマップを見る。真ん中のマップに基づいて扱ってゆく。これこそARMがどうなっているかそのものだからだ。左側は我々が直接アクセス出来ない、たぶんGPUはできるてARMできない。真ん中の図で言われているようにARMは基本的にサイズにして0x40000000 bytesのメモリ空間からなる。図の下部はトータルのSDRAMを示す。0とRAMのトップ間のある場所はSDRAM(for the ARM)に、ある塊はVC SDRAMに、基本的に、GPUのメモリとメモリはARMとGPUの間で共有されARMにGPUへ描画するよう頼むことがきでるようになっている。256MByteは0x10000000, 512MByteは0x20000000。あるraspberry piモデルは256MBもち、新しいモデルは512MBをトータルRAMとしてもち、GPUとARMに分割されている。ARMは最低でも半分持っているはず。ペリフェラル( UART, GPIO, etc)はARMアドレス空間の0x20000000にマップされている。0x7Exxxxxxをマニュアルで見た時、0x20xxxxxxをARM物理アドレスとして置き換えるべき。実験的にメモリを0x40000000毎に繰り返し見た。0x40008000を読むと、0x8000からデータを見るだろう。Broadcomのドキュメントによれば、我々に異なるキャッシュスキームで上位アドレスbitに依存してメモリアクセスを与えてくれるようだ。より多くのRAMスペースのために、raspberry pi 2はペリフェラルベースアドレス0x3Fxxxxxxを0x20xxxxxxの代わりに使っている。

原著者は通常.bssゼロ埋めはせず.dataも使わないので、例でこんなことをするときは、

int x;
fun()
{
  static int y;
}

プログラム開始時にxとyは0だと仮定しない。こんなことをするときも

int x=5;
fun()
{
  static int y=7;
}

x=5 でも y=7でもない。

さらなる情報はbssdataディレクトリを参照。 .text, .data, .bss, (.rodata),を扱うのにはlinkerスクリプをを使うだろう。

gccライブラリもCライブラリも使っていない(??)ので、全ての例がgccクロスコンパイラを使っているわけじゃないとしても(???)ほとんどビルドするとができる(?????) footnote:[意味不明。わけわからん] 基本的にarm-none-linux-gnueabiかarm-none-eabiかは重要じゃない。よく見たわけじゃないけど、codesourcery.comはフリーライトバージョンのツールチェインを持っている。こっちはもっと楽。
https://launchpad.net/gcc-arm-embedded
ソースからツールチェインをビルドするのは https://github.com/dwelch67/build_gcc:[build_gcc]を見るといい。Linux向けだけど他の環境でもビルドできるかも。piはLinuxを動かせるのでその上でネイティブのgnuツールチェインももちろん動かせる。

我々の知る限りではraspberry piは"brickable"でない。brickableとは普通、プロセッサがブートフラッシュに頼ることであり、そのフラッシュは書き換え・消去可能で、そうするとプロセッサは正常に起動できない。brickableとbrickedはときどきjtagとかそういうスペシャルプログラミングヘッダを締め出す。人々の知見によれば、bricked boardは...bricked。でもベンダーによれば、なんか装置があってハンダとかしなくてもボードを回復できるらしい。たぶんjtagとかそのたぐいを予約済みのpinとかpadにつなぐのかな。TVのリモコンとか電卓とかを調べてみると、穴とかpadが回路にあって、バッテリケースを開けるとプリント基板があったりする。これは間違いなくプログラミングヘッダ。ようするに、raspberry pi はbrickableじゃない。簡単に抜き差しできるSDカードでもってブートするから。確かかは知らないが、これを始めてからGPUに関する情報が沢山出た。だけど、GPUコードが内蔵ROMを起動する、二つのオンチッププロセッサがSDカードを読んで、ファイルシステムを駆け巡ってbootcode.binを見つけ、RAMに読み込み起動する、のだろう。そうだとするとROMはある一回はプログラマブルか消去可能で、もし近々壊れた、消されるべきプログラムに遭遇するなんてなったらなんてラッキーなんだろう😅?それでまぁ、100%ではないがだいたい100%raspberry piはbrickableじゃないということになるんだろう。これはベアメタルでは重要事項で、とくにこれが最初にプラットフォームなら。す十年の経験でまだ時々ボードをbrickさせてしまう。回復は二度と出来ない。

サンプルを使うにあたって、巨大なSDカードは要らない。linuxイメージも要らない。永遠とも思える書き込みも要らない。 http://github.com/raspberrypi のファームを使う。このレベルで必要な最小の設定は:

ここ https://github.com/raspberrypi に行き、 リポジトリのダウンロードは要らない。ファームウェアディレクトリに行き、それからブートディレクトリに行く。bootcode.binとstart.elfのそれぞれについてクリックして別ページに行き、ViewRawし、ダウンロードされるだろう。リファレンスによるとconfig.txtをSDカードに配置しない。bootcode.bin,start.elf,kernel.imgかkernel7.img(あるいは両方)のみである。

例は基本的なkernel.imgである。linuxカーネルではない。単にベアメタルプログラムである。GPUブートローダーがそのファイル名を探しに行くから使うだけ。メモリにコピーされるので、その名前自体に心配する必要はない。

SDカードを単一パーティションでセットアップし、fat32でフォーマット。上記のファイルをルートにコピーする。bootcode.binとstart.elfね。.binファイルを持ってきてkernel.imgと配置。これが面倒なのは創造に難くなく、

. 電源オフ
. SDカードを抜く
. SDカードをリーダーに挿す
. リーダーをPCに挿す
. マウント
. コピー
. sync
. アンマウント
. SDカード挿入
. 電源オン
. 以上繰り返し

これを避けるには、一つはjtag。そんなに高くない。かつては数千ドルだったが今や$50以下でソフトはフリー。raspberrypi pi はjtagをもち、大昔はjtagはハンダが必要だったが、よっぽどの新しもの好きでもない限り心配無用。使い方後々armjtagサンプルにて。

もうひとつはブートローダー、典型的にはターゲットに接続されたシリアルポートをつかう。プロセッサはブートローダーを起動し、何らかの方法でブートローダーと会話できる。そしたらプロセッサをメモリにロード、実行できる。プログラムがデバッグ中でまた試したい場合、プロセッサを再起動し、SDカードを動かすことなくまた試せる。SDカードダンスはいまブートローダーダンスに起き得られたわけだ。つまり

. 電源オフ
. 電源オン
. コマンド入力、ロード、スタート

リセットボタンをハンダしてしまえば、

. リセット
. コマンド入力、ロード、スタート

ブートローダーの例もある。bootloader05は今のとこ最新のxmodemベースのものだ(kernerl.imgを使う)。個人的にはintel hexフォーマットファイルを使うbootloader07を使う。.binファイルはbootloader05で使われ、.hexはbootloader07でつかわれる。でも追加ハードは不要(ハンダも不要)。遅れたがシリアルポートを直接raspberrypi piに繋いでは行けない。raspberrypi piが逝ってしまう。3.3V動作のものかレベルシフトがいる。おすすめはハンダなしので、

白がRXで緑がTX???::
http://www.nexuscyber.com/usb-to-ttl-serial-debug-console-cable-for-raspberry-pi
スパークファン::
https://www.sparkfun.com/products/12977
Adafruit::
https://www.adafruit.com/products/954
+
RXをTXにつなぐ。したのはハンダとかジャンパがいる。
+
http://www.sparkfun.com/products/9873
ジャンパーコードとかも::
http://www.sparkfun.com/products/9140
要ハンダ::
http://www.sparkfun.com/products/718
http://www.sparkfun.com/products/8430
COMポートレベルシフト::
http://www.sparkfun.com/products/449

あるいは、pi to piディレクトリを見るといい。これは2つのraspberry piをどうやって接続、通信させるか書いている。一つはホストで(raspberry piのLinuxはネイティブのARM開発環境でクロスコンパイラが要らない)他方はベアメタルプログラムのターゲットである。

最後に、多分私的ベストソリューションはFT4232HかFT2232Hのモジュールである。これはUARTとJTAGを$30ドル以下で手に入れられる。armjtag ディレクトリのREADMEを見るといい。メスメスジャンパーワイヤはsparkfunとか見て。 +
https://www.sparkfun.com/products/8430 +
(このジャンパーワイヤよく使うので100パック買った)

---- UARTピンの接続 ----

raspberry pi では、2行のピンヘッダがP1 footnote:[P1: 26-pin (2x13) 2.54 mm header expansion, providing: see Low-level peripheralsか。 http://elinux.org/RPi_Hardware#Schematic_.2F_Layout]。ボードの角っこから始まってる、外側の角がピン2。ピン2から黄色のRCAコネクタに向かってピン2,4,6,8,10と続く。ピン6はUSB-シリアルのGND、ピン8はraspberry piのTXで同RXにつなぐ。ピン10がraspberry piのRXで同TXにつなぐ。USB-シリアルの金属部品がraspberry piの金属部品と触らないように気をつけよう。(前述の3つの接続はもちろん例外)。ホストPCでminiconとかputtyとかの適当なテーみなるを開く。ポートをUSB-シリアルのポートに選んでボーレートを115200、データ長8bit、パリティなし、1ストップbitにする。フロー制御は要らない。miniconだとフロー制御なしにするにはconfigを保存する必要がある。ミニコンを出て、再起動してconfigをロードする。一度保存すればOK。

2  角っこの外側 +
4 +
6  GND +
8  TX +
10 RX

GNDはraspberry piとUSB-シリアルの電源が同じコンピューターなら接続しなくてもいい(接続したほうがいい)。

ブートローダーについてはそれぞれのディレクトリのREADMEについて読むこと。同様にjtagについてはarmjtagのREADMEを読む。ピンを消費するし費用も要るけどjtagが一番いいよ。典型的なやり方は、armjtagバイナリをkernel.imgとして用意して、amontecのjtag-tinyみたいなjtagボードとかminicom使ってUSB-シリアル使うのがいいよ。

amontecのWebサイトが消えた。でもj-link(とそのクローン)をebayとかで$11くらいで手に入れられる。ARMJtagとかSWDとか試してみた。いい感じ。

ハンダ付けできるなら、A+,B+,Zeroとpi 2はテキストを次に実行するための footnote:[ステップ実行のことか?]ホールがある。こんな感じのタクトスイッチを使った。 +
https://www.sparkfun.com/products/97 +
つながってない二つの足を使う。曲がっていていい感じにフィットするのでハンダする。

blinker01から始めることを勧める。そしたら、uart01とかみてそれぞれのチップについて研究してみて。

bssdataとbaremetalディレクトリはGNUツールチェインでベアメタルプログラムのビルドをするための方法についてちょっと説明してるよ。これを見た全てのベアメタルプログラマにとってこれらが基本を示し、これらがどういった仕組みで動くか考えさせ、これらを使ってみることで恐れがなくなること、また同様になぜこの方法をとったのか、を示すコメントも助けになるだろう。raspberry piはRAMベースの(GPUがバイナリをメモリに読み込む)なので、FLASH+RAMのシステムを使う際のようなことはしなくていいだろう。このRAMオンリーのやり方はとてもやりやすいが、ベアメタルのいくつか重要点を除外してしまうので各自調べるなどする必要がある。
